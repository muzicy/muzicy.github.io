[{"title":"'mixin模式'","date":"2017-03-13T11:56:44.000Z","path":"2017/03/13/mixin模式/","text":"mixin模式 –感觉类似于cpp里面的抽象出来的超类， 子类对象可以很轻松的集成超类中的属性和方法，优点:增加了函数复用，减少代码量。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Mixin模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var Car = function(settings) &#123; this.model = settings.model || 'no model provided', this.color = settings.color || 'no color provided' &#125; var Mixin = function() &#123;&#125; Mixin.prototype = &#123; driveForward: function() &#123; console.log('drive forword'); &#125;, driveBackward: function() &#123; console.log('drive backwords') &#125; &#125;; function argument(receivingClass, givingClass) &#123; if(arguments[2]) &#123; for(var i = 2, len = arguments.length; i &lt; len; i++) &#123; receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]]; &#125; &#125; else &#123; for(var key in givingClass) &#123; if(!Object.hasOwnProperty(receivingClass.prototype, key)) &#123; receivingClass.prototype[key] = givingClass.prototype[key]; &#125; &#125; &#125; &#125; //只添加特定的方法到Car里面 argument(Car, Mixin, 'driveForward', 'driveBackward'); var myCar = new Car(&#123; model:'BWM', color:'red' &#125;); myCar.driveForward(); myCar.driveBackward(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"'pub/sub模式的实现'","date":"2017-03-13T07:40:44.000Z","path":"2017/03/13/pub-sub模式的实现/","text":"我也还不太清楚Observer模式和pub/sub模式的具体差别，observer模式一般是用pub/sub模式的变量来实现， Observer要求希望接收到主题通知的贯彻着必须订阅内容改变的事件。Pub/Sub模式使用一个事件通道， 通道介于发布者与订阅着之间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pub/sub模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var Observers = &#123; observers: [], addObserver: function addObserver(newObserver) &#123; this.observers.push(newObserver); &#125;, removeObserver: function removeObserver(observer) &#123; for(var i = 0, len = observers.length; i &lt; len; i++) &#123; if(this.observers[i] == observer) &#123; this.observers.splice(i,1); &#125; &#125; &#125;, notifyObserver: function notifyObserver(value) &#123; var len = this.observers.length; while(len--) &#123; this.observers[len].update(value); &#125; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; check.update = function(value) &#123; this.checked = value; &#125; Observers.addObserver(check); showContents.appendChild(check); &#125; notifyBtn.onclick = function() &#123; var value = notifyBtn.checked; Observers.notifyObserver(value); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Observer模式的实现'","date":"2017-03-13T07:32:17.000Z","path":"2017/03/13/Observer模式的实现/","text":"简单的实现一个观察者模式,与发布订阅者模式的区别在于发布对象的变化是直接通知观察着对象，pub/sub模式中间多一个list，fire的时候会通知到订阅者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;观察者模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function ObserverList() &#123; this.observersList = []; &#125; ObserverList.prototype.addObserver = function(newObserver) &#123; this.observersList .push(newObserver); &#125; ObserverList.removeObserver = function(observer) &#123; for(var i = 0, len = this.observersList .length; i &lt; len; i++) &#123; if(this.observersList [i] == observer) &#123; this.observersList .splice(i,1); &#125; &#125; &#125; //subject function Subject() &#123; this.observers = new ObserverList(); &#125; Subject.prototype.AddObserver = function(observer) &#123; this.observers.addObserver(observer); &#125; Subject.prototype.Notify = function(context) &#123; for(var i = 0, len = this.observers.length; i &lt; len; i++) &#123; this.observers[i].update(context); console.log('notify') &#125; &#125; function extend(obj, extension) &#123; for (var key in obj) &#123; extension[key] = obj[key]; &#125; &#125; function Observer() &#123; this.update = function() &#123; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; extend(new Subject(), notifyBtn); addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; extend(new Observer(), check) check.update = function(value) &#123; this.checked = value; &#125; notifyBtn.AddObserver(check); showContents.appendChild(check); &#125; notifyBtn['onclick'] = new Function(\"notifyBtn.Notify(notifyBtn.checked)\"); &lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Module（模块模式）'","date":"2017-03-13T03:50:37.000Z","path":"2017/03/13/Module（模块模式）/","text":"在js中，实现模块的方法有: 对象字面量表示法 Module模式 AMD模式 CommonJS模式 ECMAScript Hanmony 模式。 1.对象字面量模式 该模式比较简单， 就是我们最常用的构造对象的方式。 12345678var person = &#123; name:'muzi', age:'**', sex:'f'， likeMethods: function() &#123; return 'thinking' &#125;&#125; 对象字面有助于封装和组代码。 Module(模块)模式为类提供私有和公有的封装方法，在js中进一步模拟类 的实现。 Module模式使用闭包包装私有状态和组织，在该模式中，返回一个共有的API，其他的一切则维持在私有闭包里，该模式返回的是一个对象，如果返回的是一个函数的话，就和立即调用的表达式比较类似了。 代码实现123456789101112131415161718var testModule = (function() &#123; var count = 0; return &#123; incrementCounter: function() &#123; count++; &#125;, resetConunter: function() &#123; console.log('count value prior to reset:' + count); count = 0; &#125; &#125;&#125;)//调用:testModule.incementCounter();testModule.resetCounter(); 可以看到，唯一能访问count这一私有变量的只有testModule返回的对象的这两个方法。当然，也可以在该模式下添加共有变量和私有方法。 用这种模式实现一个购物车的实例 12345678910111213141516171819202122232425262728293031var basketModule = (function() &#123; var baskt = []; function dosomethingPrivate() &#123; &#125; function dosomethingElsePrivate() &#123;&#125; return &#123; addItem: function(values) &#123; basket.push(values); &#125;, getItemCount: function() &#123; return basket.length; &#125;, dosomething: dosomethingPrivate, getTotal； function() &#123; var itemCount = this.getItemCount(), total = 0; while(itemCount--) &#123; total += basket[itemCount].price; &#125; return total; &#125; &#125;&#125;) 模块模式的优点：1 使得代码更加整洁。 2. 支持数据的私有性，只有模块中的方法可以访问私有数据。 Revealing Module(揭示模块)模式这一模式能够在私有范围内简单的定义所有函数和变量，并且返回一个匿名对象，它拥有指向私有函数的指针。 代码实现12345678910111213141516171819202122var myRevalingModule = &#123; var privatename = 'zhangsan', publicVal = 'Hello ,welcome'; function privateFunction() &#123; console.log('name: ' + privateName); &#125; function publicGetName() &#123; privateFunction(); &#125; function publicSetName(value) &#123; privateName = value; &#125; return &#123; setName: publicSetName, getName: publicGetName, greetings: publicVal &#125;&#125; 相比与上一模块模式而言，很显然揭示模块模式返回对象简单，代码更加清晰，改善可读性。","tags":[]},{"title":"","date":"2017-03-12T13:45:48.801Z","path":"2017/03/12/jq源码-事件机制1/","text":"title: jq源码-事件机制1date: 2017-03-12 21:45:48 tags:事件绑定接口有: bind, unbind, delegate,undelegate, on, one, off, trigger, triggerHandler. 以click例 :12345jQuery.fn[ 'click' ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name );&#125;; bind方式123bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn )&#125; 同样调用的this.on/this.off。delegate方式123delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn )&#125; one方式123one: function( types, selector, data, fn ) &#123; return this.on( types, selector, data, fn, 1 )&#125;","tags":[]},{"title":"","date":"2017-03-12T12:34:21.799Z","path":"2017/03/12/js深度遍历对象的属性/","text":"title: js深度遍历对象的属性date: 2017-03-12 20:34:21 tags:前端考试题(3.11)如何深度遍历一个对象的属性代码实现: 1234567891011121314151617181920212223242526function optionalChaining(obj, chain) &#123; if (obj === null || obj == undefined) &#123; return 'undefined'; &#125; if(!(/\\./g).test(chain) &amp;&amp; obj[chain]) &#123; return obj[chain]; &#125; var arr = chain.split('.'); var len = arr.length, i=0; var local = ''; var local = arr.shift(); for (key in obj) &#123; // console.log(key === local &amp;&amp; obj[key] instanceof Object ) if (key === local &amp;&amp; obj[key] instanceof Object ) &#123; return optionalChaining(obj[key], arr.join('.')); &#125; &#125; return 'undefined' ; &#125;","tags":[]},{"title":"Hello World","date":"2017-03-12T12:29:54.614Z","path":"2017/03/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]