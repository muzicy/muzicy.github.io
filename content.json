[{"title":"JQuery源码中extend方法了解","date":"2017-03-16T01:49:09.000Z","path":"2017/03/16/JQuery源码中extend方法了解/","text":"jQuery.extend(obj)是为扩展Jquery类本身而添加的方法，可以理解为静态方法, jQuery.fn.extend(obj)因为jQuery.fn = jQuery.prototype 因此可以看到是为jQuery类添加成员函数， jQuery类的实例可以共享这个方法。jQuery.extend() 的调用并不会把方法扩展到对象的实例上，引用它的方法也需要通过jQuery类来实现，如jQuery.ajax()，而 jQuery.fn.extend()的调用把方法扩展到了对象的prototype上，所以实例化一个jQuery对象的时候，它就具有了这些方法. jQuery.extend( target, object1, [objectN]) 返回被扩展的对象jQuery.fn.extend(object); 源码如下： 代码中可以看到jQuery.extend = jQuery.fn.extend 这两者共享同一个方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 假设现在要编写一个插件12345678$.fn.extend(&#123; alertWhileClick:function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125; &#125;); $(\"#obtn\").alertWhileClick(); 从上面的代码可以看到，这个插件方法是扩展到Juqery类中的原型中的方法， 因此被Jquery的实例所共享。或者在Jquery对象上扩展方法，如图$.ajax()方法一样是可以直接由这个对象所调用12345678$.extend(&#123; alertWhileClick:function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125; &#125;); $.alertWhileClick();","tags":[{"name":"Jquery","slug":"Jquery","permalink":"https://muzicy.github.io/tags/Jquery/"}]},{"title":"JQuery源码构造Jquery对象","date":"2017-03-16T01:08:31.000Z","path":"2017/03/16/JQuery源码构造Jquery对象/","text":"整个jquery源码是一个立即执行函数,并传递两个参数进去， 一个是全局对象window， 另外一个是工厂模式的函数。因为在传递的函数内部最后 return JQuery对象， 因此说它是工厂模式的函数123456789101112131415161718192021222324252627( function( global, factory ) &#123; \"use strict\"; if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // For CommonJS and CommonJS-like environments where a proper `window` // is present, execute the factory and get jQuery. // For environments that do not have a `window` with a `document` // (such as Node.js), expose a factory as module.exports. // This accentuates the need for the creation of a real `window`. // e.g. var jQuery = require(\"jquery\")(window); // See ticket #14549 for more info. module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal )&#123;&#125; 2 为什么我们在构造jquery对象时不需要加new. 我们获取一个对象是通过 $(‘#obtn’) 而不是new $(‘#obtn’);这是因为在Jquery构造函数的内部本身就返回的是一个new 的对象123456jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context ); &#125; 有疑问，这个Jquery.fn.init是个什么鬼， 设想一下，如果按照我们的常理思维返回Jquery构造函数的实例肯定是这样写这个构造函数123456jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery( selector, context ); &#125; 但是这样就出问题了， 出现一个不停的循环调用的状况，怎么办呢？ 作者于是就将返回的Jquery对象用另一个名字来代替，也就是Jquery.fn.init().Jquery.fn.init方法定义如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106init = jQuery.fn.init = function( selector, context, root ) &#123; var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false) if ( !selector ) &#123; return this; &#125; // Method init() accepts an alternate rootjQuery // so migrate can support jQuery.sub (gh-2101) root = root || rootjQuery; // Handle HTML strings if ( typeof selector === \"string\" ) &#123; if ( selector[ 0 ] === \"&lt;\" &amp;&amp; selector[ selector.length - 1 ] === \"&gt;\" &amp;&amp; selector.length &gt;= 3 ) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; &#125; else &#123; match = rquickExpr.exec( selector ); &#125; // Match html or make sure no context is specified for #id if ( match &amp;&amp; ( match[ 1 ] || !context ) ) &#123; // HANDLE: $(html) -&gt; $(array) if ( match[ 1 ] ) &#123; context = context instanceof jQuery ? context[ 0 ] : context; // Option to run scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge( this, jQuery.parseHTML( match[ 1 ], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true ) ); // HANDLE: $(html, props) if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; for ( match in context ) &#123; // Properties of context are called as methods if possible if ( jQuery.isFunction( this[ match ] ) ) &#123; this[ match ]( context[ match ] ); // ...and otherwise set as attributes &#125; else &#123; this.attr( match, context[ match ] ); &#125; &#125; &#125; return this; // HANDLE: $(#id) &#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this; &#125; // HANDLE: $(expr, $(...)) &#125; else if ( !context || context.jquery ) &#123; return ( context || root ).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) &#125; else &#123; return this.constructor( context ).find( selector ); &#125; // HANDLE: $(DOMElement) &#125; else if ( selector.nodeType ) &#123; this[ 0 ] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready &#125; else if ( jQuery.isFunction( selector ) ) &#123; return root.ready !== undefined ? root.ready( selector ) : // Execute immediately if ready is not present selector( jQuery ); &#125; return jQuery.makeArray( selector, this ); &#125;;// Give the init function the jQuery prototype for later instantiationinit.prototype = jQuery.fn;//相当于是jQuery.fn.init.prototype = JQuery.fn = JQuery.prototype//这样JQuery.fn.init的实例也就继承了JQuery原型对象中的方法，这一步进一步说明了在JQuery原型对象中添加的方法会被jQuery.fn.init的实例和JQuery.fn对象所共享 Jquery.fn是用对象字面量函数定义的一个对象, Jquery.fn = jQuery.prototype，在这个对象里面的方法和属性都是被Jquery类的实例所共享的，因此我们可以调用代码如下:将Jquery.fn对象指向Jquery的原型对象，那么JQuery.fn对象共享Jquery对象上的方法，从这段代码可看出 $.fn.method == $(‘selelctor’).method,这也就是为啥 $.fn.extend == $(selector).fn.extend的原因吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // The default length of a jQuery object is 0 length: 0, toArray: function() &#123; return slice.call( this ); &#125;, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function( num ) &#123; // Return all the elements in a clean array if ( num == null ) &#123; return slice.call( this ); &#125; // Return just the one element from the set return num &lt; 0 ? this[ num + this.length ] : this[ num ]; &#125;, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function( elems ) &#123; // Build a new jQuery matched element set var ret = jQuery.merge( this.constructor(), elems ); // Add the old object onto the stack (as a reference) ret.prevObject = this; // Return the newly-formed element set return ret; &#125;, // Execute a callback for every element in the matched set. each: function( callback ) &#123; return jQuery.each( this, callback ); &#125;, map: function( callback ) &#123; return this.pushStack( jQuery.map( this, function( elem, i ) &#123; return callback.call( elem, i, elem ); &#125; ) ); &#125;, slice: function() &#123; return this.pushStack( slice.apply( this, arguments ) ); &#125;, first: function() &#123; return this.eq( 0 ); &#125;, last: function() &#123; return this.eq( -1 ); &#125;, eq: function( i ) &#123; var len = this.length, j = +i + ( i &lt; 0 ? len : 0 ); return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] ); &#125;, end: function() &#123; return this.prevObject || this.constructor(); &#125;, // For internal use only. // Behaves like an Array's method, not like a jQuery method. push: push, sort: arr.sort, splice: arr.splice&#125;;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://muzicy.github.io/tags/jquery/"}]},{"title":"理解作用域链","date":"2017-03-15T08:05:33.000Z","path":"2017/03/15/理解作用域链/","text":"有些东西很奇怪，明明看的时候很理解了， 等到过两天在去想是什么意思的时候， 就又开始说不清楚了， js中的作用域与作用域链大概就是这种感觉，大概这就是为什么我觉得它不好理解的原因吧，所以提笔记下来看看会不会清楚些， 通过高性能js理解。 作用域作用域在js中分为全局作用域和函数作用域。 在最外层函数和最外层函数外面定义的函数和变量拥有全局作用域， 所有未定义直接赋值的变量自动声明为拥有全局作用域， 所有window对象的属性也拥有全局作用域。 在函数内通过var 和非闭包形式定义的函数拥有函数作用域也就是局部作用域。 作用域链每一个js函数都是Function的一个实例， 是一个对象，在内部拥有一个[[Scope]]的属性，该属性包含了函数被创建的作用域中对象的集合，这个集合也就是称为函数的作用域链，它决定哪些数据能被函数访问， 函数作用域中的每一个对象被称为一个可变对象， 当一个函数被创建后，它的作用域链包含了可访问的数据对象。 1234function sum(num1, num2) &#123; var sum = num1 + num2; return sum;&#125; 该函数在全局作用域中被创建， 它的作用域链中填入了一个氮素的可变对象， 这个全局对象包含了所有全局范围的定义的变量，如window,navigator, document等。 add的作用域链将会在执行时用到1var total = sum(5, 10); 函数在执行时会有一个执行环境，这一执行环境是独一无二的。每个运行期上下文都有自己的作用域链， 它的作用域链初始化为当前运行函数的[[Scope]], 这个值按照他们出现在函数中的顺序被复制到执行器上下文的作用域链中， 一但复制完， 一个呗称为活动对象的新对象就为执行期上下文创建好了， 活动对象时指函数运行期的可变对象， 包含了所有局部变量， 命名参数， 集合参数和this, 然后此对象被推入作用域链的前端， 当运行期上下文被销毁， 活动对象也随之销毁。 总结：也就是说函数在创建的时候会有一个作用域链， 在函数调用时也会有一个作用域链， 这两个作用域链不一样， 在创建时对应的有一个变量对象，在调用时，作用域链中除了包含这个变量对象，也会创建一个变量对象， 在函数的执行过程中，每遇到一个变量，都会经历一次变量在作用域中查找的过程。 ps:码字的时候挺清晰的，可以让我去回答面试官这个问题估计又会说不清楚了。。。。","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"ajax知识点","date":"2017-03-15T01:59:08.000Z","path":"2017/03/15/ajax知识点/","text":"Ajax的具体详解见文章Ajax知识体系大梳理,感谢作者如此细心的整理，将此文章转载过来以便自己不时的复习。 ajax的同步异步代码实现（见js高程设计书）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax的同步异步&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; function getXHR() &#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if(window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch(e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch(e) &#123; alert('您的浏览器不支持Ajax'); &#125; &#125; &#125; return xhr; &#125; var xhr= getXHR() //xhr的同步调用 xhr.open('get', RUL, false); xhr.send(null); if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseXML); &#125; else &#123; alert('request was unsuccessful'); &#125; //xhr的异步调用，通过onreadystateschange的状态来判断 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; alert('request failed '+ xhr.status); &#125; &#125; &#125; xhr.open('get', URL, true); xhr.send(null); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"ajax","slug":"ajax","permalink":"https://muzicy.github.io/tags/ajax/"}]},{"title":"检测数组的方法","date":"2017-03-14T08:45:38.000Z","path":"2017/03/14/检测数组的方法/","text":"如何通过js判断一个数组 arr instanceof Array constructor 的方法 arr.constructor == Array 利用数组也有的特性判断，比如splice Object.splice == ‘function’ 但是该方法有时候会失效。 123Object.prototype.toString.call(arr) //[Object Array] var isArr = Object.prototype.toString.call(arr).slice(8,-1) === 'Array' ES5新增加的isArray()方法","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"'mixin模式'","date":"2017-03-13T11:56:44.000Z","path":"2017/03/13/mixin模式/","text":"mixin模式 –感觉类似于cpp里面的抽象出来的超类， 子类对象可以很轻松的集成超类中的属性和方法，优点:增加了函数复用，减少代码量。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Mixin模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var Car = function(settings) &#123; this.model = settings.model || 'no model provided', this.color = settings.color || 'no color provided' &#125; var Mixin = function() &#123;&#125; Mixin.prototype = &#123; driveForward: function() &#123; console.log('drive forword'); &#125;, driveBackward: function() &#123; console.log('drive backwords') &#125; &#125;; function argument(receivingClass, givingClass) &#123; if(arguments[2]) &#123; for(var i = 2, len = arguments.length; i &lt; len; i++) &#123; receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]]; &#125; &#125; else &#123; for(var key in givingClass) &#123; if(!Object.hasOwnProperty(receivingClass.prototype, key)) &#123; receivingClass.prototype[key] = givingClass.prototype[key]; &#125; &#125; &#125; &#125; //只添加特定的方法到Car里面 argument(Car, Mixin, 'driveForward', 'driveBackward'); var myCar = new Car(&#123; model:'BWM', color:'red' &#125;); myCar.driveForward(); myCar.driveBackward(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"'pub/sub模式的实现'","date":"2017-03-13T07:40:44.000Z","path":"2017/03/13/pub-sub模式的实现/","text":"我也还不太清楚Observer模式和pub/sub模式的具体差别，observer模式一般是用pub/sub模式的变量来实现， Observer要求希望接收到主题通知的贯彻着必须订阅内容改变的事件。Pub/Sub模式使用一个事件通道， 通道介于发布者与订阅着之间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pub/sub模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var Observers = &#123; observers: [], addObserver: function addObserver(newObserver) &#123; this.observers.push(newObserver); &#125;, removeObserver: function removeObserver(observer) &#123; for(var i = 0, len = observers.length; i &lt; len; i++) &#123; if(this.observers[i] == observer) &#123; this.observers.splice(i,1); &#125; &#125; &#125;, notifyObserver: function notifyObserver(value) &#123; var len = this.observers.length; while(len--) &#123; this.observers[len].update(value); &#125; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; check.update = function(value) &#123; this.checked = value; &#125; Observers.addObserver(check); showContents.appendChild(check); &#125; notifyBtn.onclick = function() &#123; var value = notifyBtn.checked; Observers.notifyObserver(value); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Observer模式的实现'","date":"2017-03-13T07:32:17.000Z","path":"2017/03/13/Observer模式的实现/","text":"简单的实现一个观察者模式,与发布订阅者模式的区别在于发布对象的变化是直接通知观察着对象，pub/sub模式中间多一个list，fire的时候会通知到订阅者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;观察者模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function ObserverList() &#123; this.observersList = []; &#125; ObserverList.prototype.addObserver = function(newObserver) &#123; this.observersList .push(newObserver); &#125; ObserverList.removeObserver = function(observer) &#123; for(var i = 0, len = this.observersList .length; i &lt; len; i++) &#123; if(this.observersList [i] == observer) &#123; this.observersList .splice(i,1); &#125; &#125; &#125; //subject function Subject() &#123; this.observers = new ObserverList(); &#125; Subject.prototype.AddObserver = function(observer) &#123; this.observers.addObserver(observer); &#125; Subject.prototype.Notify = function(context) &#123; for(var i = 0, len = this.observers.length; i &lt; len; i++) &#123; this.observers[i].update(context); console.log('notify') &#125; &#125; function extend(obj, extension) &#123; for (var key in obj) &#123; extension[key] = obj[key]; &#125; &#125; function Observer() &#123; this.update = function() &#123; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; extend(new Subject(), notifyBtn); addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; extend(new Observer(), check) check.update = function(value) &#123; this.checked = value; &#125; notifyBtn.AddObserver(check); showContents.appendChild(check); &#125; notifyBtn['onclick'] = new Function(\"notifyBtn.Notify(notifyBtn.checked)\"); &lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Module（模块模式）'","date":"2017-03-13T03:50:37.000Z","path":"2017/03/13/Module（模块模式）/","text":"在js中，实现模块的方法有: 对象字面量表示法 Module模式 AMD模式 CommonJS模式 ECMAScript Hanmony 模式。 1.对象字面量模式 该模式比较简单， 就是我们最常用的构造对象的方式。 12345678var person = &#123; name:'muzi', age:'**', sex:'f'， likeMethods: function() &#123; return 'thinking' &#125;&#125; 对象字面有助于封装和组代码。 Module(模块)模式为类提供私有和公有的封装方法，在js中进一步模拟类 的实现。 Module模式使用闭包包装私有状态和组织，在该模式中，返回一个共有的API，其他的一切则维持在私有闭包里，该模式返回的是一个对象，如果返回的是一个函数的话，就和立即调用的表达式比较类似了。 代码实现123456789101112131415161718var testModule = (function() &#123; var count = 0; return &#123; incrementCounter: function() &#123; count++; &#125;, resetConunter: function() &#123; console.log('count value prior to reset:' + count); count = 0; &#125; &#125;&#125;)//调用:testModule.incementCounter();testModule.resetCounter(); 可以看到，唯一能访问count这一私有变量的只有testModule返回的对象的这两个方法。当然，也可以在该模式下添加共有变量和私有方法。 用这种模式实现一个购物车的实例 12345678910111213141516171819202122232425262728293031var basketModule = (function() &#123; var baskt = []; function dosomethingPrivate() &#123; &#125; function dosomethingElsePrivate() &#123;&#125; return &#123; addItem: function(values) &#123; basket.push(values); &#125;, getItemCount: function() &#123; return basket.length; &#125;, dosomething: dosomethingPrivate, getTotal； function() &#123; var itemCount = this.getItemCount(), total = 0; while(itemCount--) &#123; total += basket[itemCount].price; &#125; return total; &#125; &#125;&#125;) 模块模式的优点：1 使得代码更加整洁。 2. 支持数据的私有性，只有模块中的方法可以访问私有数据。 Revealing Module(揭示模块)模式这一模式能够在私有范围内简单的定义所有函数和变量，并且返回一个匿名对象，它拥有指向私有函数的指针。 代码实现12345678910111213141516171819202122var myRevalingModule = &#123; var privatename = 'zhangsan', publicVal = 'Hello ,welcome'; function privateFunction() &#123; console.log('name: ' + privateName); &#125; function publicGetName() &#123; privateFunction(); &#125; function publicSetName(value) &#123; privateName = value; &#125; return &#123; setName: publicSetName, getName: publicGetName, greetings: publicVal &#125;&#125; 相比与上一模块模式而言，很显然揭示模块模式返回对象简单，代码更加清晰，改善可读性。","tags":[]},{"title":"jq源码-事件机制1","date":"2017-03-12T13:45:48.000Z","path":"2017/03/12/jq源码-事件机制1/","text":"事件绑定接口有: bind, unbind, delegate,undelegate, on, one, off, trigger, triggerHandler. 以click例 :12345jQuery.fn[ 'click' ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name );&#125;; bind方式123bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn )&#125; 同样调用的this.on/this.off。delegate方式123delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn )&#125; one方式123one: function( types, selector, data, fn ) &#123; return this.on( types, selector, data, fn, 1 )&#125;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://muzicy.github.io/tags/jquery/"}]},{"title":"js深度遍历对象的属性","date":"2017-03-12T12:34:21.000Z","path":"2017/03/12/js深度遍历对象的属性/","text":"前端考试题(3.11)如何深度遍历一个对象的属性代码实现: 1234567891011121314151617181920212223242526function optionalChaining(obj, chain) &#123; if (obj === null || obj == undefined) &#123; return 'undefined'; &#125; if(!(/\\./g).test(chain) &amp;&amp; obj[chain]) &#123; return obj[chain]; &#125; var arr = chain.split('.'); var len = arr.length, i=0; var local = ''; var local = arr.shift(); for (key in obj) &#123; // console.log(key === local &amp;&amp; obj[key] instanceof Object ) if (key === local &amp;&amp; obj[key] instanceof Object ) &#123; return optionalChaining(obj[key], arr.join('.')); &#125; &#125; return 'undefined' ; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"Hello World","date":"2017-03-12T12:29:54.614Z","path":"2017/03/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]