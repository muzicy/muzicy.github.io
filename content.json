[{"title":"理解作用域链","date":"2017-03-15T08:05:33.000Z","path":"2017/03/15/理解作用域链/","text":"有些东西很奇怪，明明看的时候很理解了， 等到过两天在去想是什么意思的时候， 就又开始说不清楚了， js中的作用域与作用域链大概就是这种感觉，大概这就是为什么我觉得它不好理解的原因吧，所以提笔记下来看看会不会清楚些， 通过高性能js理解。 作用域作用域在js中分为全局作用域和函数作用域。 在最外层函数和最外层函数外面定义的函数和变量拥有全局作用域， 所有未定义直接赋值的变量自动声明为拥有全局作用域， 所有window对象的属性也拥有全局作用域。 在函数内通过var 和非闭包形式定义的函数拥有函数作用域也就是局部作用域。 作用域链每一个js函数都是Function的一个实例， 是一个对象，在内部拥有一个[[Scope]]的属性，该属性包含了函数被创建的作用域中对象的集合，这个集合也就是称为函数的作用域链，它决定哪些数据能被函数访问， 函数作用域中的每一个对象被称为一个可变对象， 当一个函数被创建后，它的作用域链包含了可访问的数据对象。 1234function sum(num1, num2) &#123; var sum = num1 + num2; return sum;&#125; 该函数在全局作用域中被创建， 它的作用域链中填入了一个氮素的可变对象， 这个全局对象包含了所有全局范围的定义的变量，如window,navigator, document等。 add的作用域链将会在执行时用到1var total = sum(5, 10); 函数在执行时会有一个执行环境，这一执行环境是独一无二的。每个运行期上下文都有自己的作用域链， 它的作用域链初始化为当前运行函数的[[Scope]], 这个值按照他们出现在函数中的顺序被复制到执行器上下文的作用域链中， 一但复制完， 一个呗称为活动对象的新对象就为执行期上下文创建好了， 活动对象时指函数运行期的可变对象， 包含了所有局部变量， 命名参数， 集合参数和this, 然后此对象被推入作用域链的前端， 当运行期上下文被销毁， 活动对象也随之销毁。 总结：也就是说函数在创建的时候会有一个作用域链， 在函数调用时也会有一个作用域链， 这两个作用域链不一样， 在创建时对应的有一个变量对象，在调用时，作用域链中除了包含这个变量对象，也会创建一个变量对象， 在函数的执行过程中，每遇到一个变量，都会经历一次变量在作用域中查找的过程。 ps:码字的时候挺清晰的，可以让我去回答面试官这个问题估计又会说不清楚了。。。。","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"ajax知识点","date":"2017-03-15T01:59:08.000Z","path":"2017/03/15/ajax知识点/","text":"Ajax的具体详解见文章Ajax知识体系大梳理,感谢作者如此细心的整理，将此文章转载过来以便自己不时的复习。 ajax的同步异步代码实现（见js高程设计书）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax的同步异步&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; function getXHR() &#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if(window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch(e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch(e) &#123; alert('您的浏览器不支持Ajax'); &#125; &#125; &#125; return xhr; &#125; var xhr= getXHR() //xhr的同步调用 xhr.open('get', RUL, false); xhr.send(null); if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseXML); &#125; else &#123; alert('request was unsuccessful'); &#125; //xhr的异步调用，通过onreadystateschange的状态来判断 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; alert('request failed '+ xhr.status); &#125; &#125; &#125; xhr.open('get', URL, true); xhr.send(null); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"ajax","slug":"ajax","permalink":"https://muzicy.github.io/tags/ajax/"}]},{"title":"检测数组的方法","date":"2017-03-14T08:45:38.000Z","path":"2017/03/14/检测数组的方法/","text":"如何通过js判断一个数组 arr instanceof Array constructor 的方法 arr.constructor == Array 利用数组也有的特性判断，比如splice Object.splice == ‘function’ 但是该方法有时候会失效。 123Object.prototype.toString.call(arr) //[Object Array] var isArr = Object.prototype.toString.call(arr).slice(8,-1) === 'Array' ES5新增加的isArray()方法","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"'mixin模式'","date":"2017-03-13T11:56:44.000Z","path":"2017/03/13/mixin模式/","text":"mixin模式 –感觉类似于cpp里面的抽象出来的超类， 子类对象可以很轻松的集成超类中的属性和方法，优点:增加了函数复用，减少代码量。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Mixin模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var Car = function(settings) &#123; this.model = settings.model || 'no model provided', this.color = settings.color || 'no color provided' &#125; var Mixin = function() &#123;&#125; Mixin.prototype = &#123; driveForward: function() &#123; console.log('drive forword'); &#125;, driveBackward: function() &#123; console.log('drive backwords') &#125; &#125;; function argument(receivingClass, givingClass) &#123; if(arguments[2]) &#123; for(var i = 2, len = arguments.length; i &lt; len; i++) &#123; receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]]; &#125; &#125; else &#123; for(var key in givingClass) &#123; if(!Object.hasOwnProperty(receivingClass.prototype, key)) &#123; receivingClass.prototype[key] = givingClass.prototype[key]; &#125; &#125; &#125; &#125; //只添加特定的方法到Car里面 argument(Car, Mixin, 'driveForward', 'driveBackward'); var myCar = new Car(&#123; model:'BWM', color:'red' &#125;); myCar.driveForward(); myCar.driveBackward(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"'pub/sub模式的实现'","date":"2017-03-13T07:40:44.000Z","path":"2017/03/13/pub-sub模式的实现/","text":"我也还不太清楚Observer模式和pub/sub模式的具体差别，observer模式一般是用pub/sub模式的变量来实现， Observer要求希望接收到主题通知的贯彻着必须订阅内容改变的事件。Pub/Sub模式使用一个事件通道， 通道介于发布者与订阅着之间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pub/sub模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var Observers = &#123; observers: [], addObserver: function addObserver(newObserver) &#123; this.observers.push(newObserver); &#125;, removeObserver: function removeObserver(observer) &#123; for(var i = 0, len = observers.length; i &lt; len; i++) &#123; if(this.observers[i] == observer) &#123; this.observers.splice(i,1); &#125; &#125; &#125;, notifyObserver: function notifyObserver(value) &#123; var len = this.observers.length; while(len--) &#123; this.observers[len].update(value); &#125; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; check.update = function(value) &#123; this.checked = value; &#125; Observers.addObserver(check); showContents.appendChild(check); &#125; notifyBtn.onclick = function() &#123; var value = notifyBtn.checked; Observers.notifyObserver(value); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Observer模式的实现'","date":"2017-03-13T07:32:17.000Z","path":"2017/03/13/Observer模式的实现/","text":"简单的实现一个观察者模式,与发布订阅者模式的区别在于发布对象的变化是直接通知观察着对象，pub/sub模式中间多一个list，fire的时候会通知到订阅者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;观察者模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function ObserverList() &#123; this.observersList = []; &#125; ObserverList.prototype.addObserver = function(newObserver) &#123; this.observersList .push(newObserver); &#125; ObserverList.removeObserver = function(observer) &#123; for(var i = 0, len = this.observersList .length; i &lt; len; i++) &#123; if(this.observersList [i] == observer) &#123; this.observersList .splice(i,1); &#125; &#125; &#125; //subject function Subject() &#123; this.observers = new ObserverList(); &#125; Subject.prototype.AddObserver = function(observer) &#123; this.observers.addObserver(observer); &#125; Subject.prototype.Notify = function(context) &#123; for(var i = 0, len = this.observers.length; i &lt; len; i++) &#123; this.observers[i].update(context); console.log('notify') &#125; &#125; function extend(obj, extension) &#123; for (var key in obj) &#123; extension[key] = obj[key]; &#125; &#125; function Observer() &#123; this.update = function() &#123; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; extend(new Subject(), notifyBtn); addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; extend(new Observer(), check) check.update = function(value) &#123; this.checked = value; &#125; notifyBtn.AddObserver(check); showContents.appendChild(check); &#125; notifyBtn['onclick'] = new Function(\"notifyBtn.Notify(notifyBtn.checked)\"); &lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Module（模块模式）'","date":"2017-03-13T03:50:37.000Z","path":"2017/03/13/Module（模块模式）/","text":"在js中，实现模块的方法有: 对象字面量表示法 Module模式 AMD模式 CommonJS模式 ECMAScript Hanmony 模式。 1.对象字面量模式 该模式比较简单， 就是我们最常用的构造对象的方式。 12345678var person = &#123; name:'muzi', age:'**', sex:'f'， likeMethods: function() &#123; return 'thinking' &#125;&#125; 对象字面有助于封装和组代码。 Module(模块)模式为类提供私有和公有的封装方法，在js中进一步模拟类 的实现。 Module模式使用闭包包装私有状态和组织，在该模式中，返回一个共有的API，其他的一切则维持在私有闭包里，该模式返回的是一个对象，如果返回的是一个函数的话，就和立即调用的表达式比较类似了。 代码实现123456789101112131415161718var testModule = (function() &#123; var count = 0; return &#123; incrementCounter: function() &#123; count++; &#125;, resetConunter: function() &#123; console.log('count value prior to reset:' + count); count = 0; &#125; &#125;&#125;)//调用:testModule.incementCounter();testModule.resetCounter(); 可以看到，唯一能访问count这一私有变量的只有testModule返回的对象的这两个方法。当然，也可以在该模式下添加共有变量和私有方法。 用这种模式实现一个购物车的实例 12345678910111213141516171819202122232425262728293031var basketModule = (function() &#123; var baskt = []; function dosomethingPrivate() &#123; &#125; function dosomethingElsePrivate() &#123;&#125; return &#123; addItem: function(values) &#123; basket.push(values); &#125;, getItemCount: function() &#123; return basket.length; &#125;, dosomething: dosomethingPrivate, getTotal； function() &#123; var itemCount = this.getItemCount(), total = 0; while(itemCount--) &#123; total += basket[itemCount].price; &#125; return total; &#125; &#125;&#125;) 模块模式的优点：1 使得代码更加整洁。 2. 支持数据的私有性，只有模块中的方法可以访问私有数据。 Revealing Module(揭示模块)模式这一模式能够在私有范围内简单的定义所有函数和变量，并且返回一个匿名对象，它拥有指向私有函数的指针。 代码实现12345678910111213141516171819202122var myRevalingModule = &#123; var privatename = 'zhangsan', publicVal = 'Hello ,welcome'; function privateFunction() &#123; console.log('name: ' + privateName); &#125; function publicGetName() &#123; privateFunction(); &#125; function publicSetName(value) &#123; privateName = value; &#125; return &#123; setName: publicSetName, getName: publicGetName, greetings: publicVal &#125;&#125; 相比与上一模块模式而言，很显然揭示模块模式返回对象简单，代码更加清晰，改善可读性。","tags":[]},{"title":"jq源码-事件机制1","date":"2017-03-12T13:45:48.000Z","path":"2017/03/12/jq源码-事件机制1/","text":"事件绑定接口有: bind, unbind, delegate,undelegate, on, one, off, trigger, triggerHandler. 以click例 :12345jQuery.fn[ 'click' ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name );&#125;; bind方式123bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn )&#125; 同样调用的this.on/this.off。delegate方式123delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn )&#125; one方式123one: function( types, selector, data, fn ) &#123; return this.on( types, selector, data, fn, 1 )&#125;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://muzicy.github.io/tags/jquery/"}]},{"title":"js深度遍历对象的属性","date":"2017-03-12T12:34:21.000Z","path":"2017/03/12/js深度遍历对象的属性/","text":"前端考试题(3.11)如何深度遍历一个对象的属性代码实现: 1234567891011121314151617181920212223242526function optionalChaining(obj, chain) &#123; if (obj === null || obj == undefined) &#123; return 'undefined'; &#125; if(!(/\\./g).test(chain) &amp;&amp; obj[chain]) &#123; return obj[chain]; &#125; var arr = chain.split('.'); var len = arr.length, i=0; var local = ''; var local = arr.shift(); for (key in obj) &#123; // console.log(key === local &amp;&amp; obj[key] instanceof Object ) if (key === local &amp;&amp; obj[key] instanceof Object ) &#123; return optionalChaining(obj[key], arr.join('.')); &#125; &#125; return 'undefined' ; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"Hello World","date":"2017-03-12T12:29:54.614Z","path":"2017/03/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]