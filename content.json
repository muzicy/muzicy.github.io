[{"title":"'Module（模块模式）'","date":"2017-03-13T03:50:37.000Z","path":"2017/03/13/Module（模块模式）/","text":"在js中，实现模块的方法有: 对象字面量表示法 Module模式 AMD模式 CommonJS模式 ECMAScript Hanmony 模式。 1.对象字面量模式 该模式比较简单， 就是我们最常用的构造对象的方式。 12345678var person = &#123; name:'muzi', age:'**', sex:'f'， likeMethods: function() &#123; return 'thinking' &#125;&#125; 对象字面有助于封装和组代码。 Module(模块)模式为类提供私有和公有的封装方法，在js中进一步模拟类 的实现。 Module模式使用闭包包装私有状态和组织，在该模式中，返回一个共有的API，其他的一切则维持在私有闭包里，该模式返回的是一个对象，如果返回的是一个函数的话，就和立即调用的表达式比较类似了。 代码实现123456789101112131415161718var testModule = (function() &#123; var count = 0; return &#123; incrementCounter: function() &#123; count++; &#125;, resetConunter: function() &#123; console.log('count value prior to reset:' + count); count = 0; &#125; &#125;&#125;)//调用:testModule.incementCounter();testModule.resetCounter(); 可以看到，唯一能访问count这一私有变量的只有testModule返回的对象的这两个方法。当然，也可以在该模式下添加共有变量和私有方法。 用这种模式实现一个购物车的实例 12345678910111213141516171819202122232425262728293031var basketModule = (function() &#123; var baskt = []; function dosomethingPrivate() &#123; &#125; function dosomethingElsePrivate() &#123;&#125; return &#123; addItem: function(values) &#123; basket.push(values); &#125;, getItemCount: function() &#123; return basket.length; &#125;, dosomething: dosomethingPrivate, getTotal； function() &#123; var itemCount = this.getItemCount(), total = 0; while(itemCount--) &#123; total += basket[itemCount].price; &#125; return total; &#125; &#125;&#125;) 模块模式的优点：1 使得代码更加整洁。 2. 支持数据的私有性，只有模块中的方法可以访问私有数据。 Revealing Module(揭示模块)模式这一模式能够在私有范围内简单的定义所有函数和变量，并且返回一个匿名对象，它拥有指向私有函数的指针。 代码实现12345678910111213141516171819202122var myRevalingModule = &#123; var privatename = 'zhangsan', publicVal = 'Hello ,welcome'; function privateFunction() &#123; console.log('name: ' + privateName); &#125; function publicGetName() &#123; privateFunction(); &#125; function publicSetName(value) &#123; privateName = value; &#125; return &#123; setName: publicSetName, getName: publicGetName, greetings: publicVal &#125;&#125; 相比与上一模块模式而言，很显然揭示模块模式返回对象简单，代码更加清晰，改善可读性。","tags":[]},{"title":"","date":"2017-03-12T13:45:48.801Z","path":"2017/03/12/jq源码-事件机制1/","text":"title: jq源码-事件机制1date: 2017-03-12 21:45:48 tags:事件绑定接口有: bind, unbind, delegate,undelegate, on, one, off, trigger, triggerHandler. 以click例 :12345jQuery.fn[ 'click' ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name );&#125;; bind方式123bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn )&#125; 同样调用的this.on/this.off。delegate方式123delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn )&#125; one方式123one: function( types, selector, data, fn ) &#123; return this.on( types, selector, data, fn, 1 )&#125;","tags":[]},{"title":"","date":"2017-03-12T12:34:21.799Z","path":"2017/03/12/js深度遍历对象的属性/","text":"title: js深度遍历对象的属性date: 2017-03-12 20:34:21 tags:前端考试题(3.11)如何深度遍历一个对象的属性代码实现: 1234567891011121314151617181920212223242526function optionalChaining(obj, chain) &#123; if (obj === null || obj == undefined) &#123; return 'undefined'; &#125; if(!(/\\./g).test(chain) &amp;&amp; obj[chain]) &#123; return obj[chain]; &#125; var arr = chain.split('.'); var len = arr.length, i=0; var local = ''; var local = arr.shift(); for (key in obj) &#123; // console.log(key === local &amp;&amp; obj[key] instanceof Object ) if (key === local &amp;&amp; obj[key] instanceof Object ) &#123; return optionalChaining(obj[key], arr.join('.')); &#125; &#125; return 'undefined' ; &#125;","tags":[]},{"title":"Hello World","date":"2017-03-12T12:29:54.614Z","path":"2017/03/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]